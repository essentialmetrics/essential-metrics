#!/usr/bin/env python
# EM-11 - Vulnerability patching timelines

from dash.dependencies import Input, Output, State
from dash import html, dcc, callback, Input, Output, dash_table, callback_context
import dash_bootstrap_components as dbc
import pandas as pd
import warnings
import plotly.express as px
import utils.common_functions as cf
import utils.common_graph_functions as cgf

from utils.database_class import DatabaseManager
from utils.logger_config  import configure_logger

logger = configure_logger(__name__)

with DatabaseManager() as db:
    em_11_vulnerability_patching = db.read_database_table('em_11_vulnerability_patching')


def generate_patching_graphs(df):
    try:
        filtered_df = df[df['Software'].str.contains('Update for Windows 11|Update for Windows 10', na=False)]

        # We first need to convert the Microsoft DateTime stamp format: 20231215060522.240996-000 into a format we can perform calculations with in pandas
        # To do this we are stripping the 4 end characters and then using pandas datetime to make the conversion
        filtered_df.loc[:, 'TimeGenerated'] = filtered_df['TimeGenerated'].str[:-4]
        filtered_df.loc[:, 'TimeGenerated'] = pd.to_datetime(filtered_df['TimeGenerated'], format='%Y%m%d%H%M%S.%f')

        # Next we need to Drop duplicate Download started rows as they are causing issues with the dataset
        # A Download started row was added after an update was already installed and it performed a backwards timestamp calculation
        duplicate_indices = filtered_df[filtered_df['EventIdentifier'] == 'Download started'].duplicated(subset='UpdateGUID', keep='last')
        indices_to_drop = filtered_df[filtered_df['EventIdentifier'] == 'Download started'][duplicate_indices].index
        filtered_df = filtered_df.drop(indices_to_drop)

        # Now we are going to group GUIDs, this is how we can track updates from the event IDs, we are going to look at the Download Started and Installed
        # We can use these to check how long it took from starting the download to the update being installed
        # We need to set this function as a simple lambda will fail if there is an update that has the Download Started Event in the database however is missing the Installed event
        # To fix this we are returning a NaT which will allow us to render the graph with an empty bar for that software version update until the user has installed it
        relevant_events = filtered_df[filtered_df['EventIdentifier'].isin(['Download started', 'Installed'])]
        def calculate_duration(group):
            if 'Installed' in group['EventIdentifier'].values and 'Download started' in group['EventIdentifier'].values:
                install_time = group[group['EventIdentifier'] == 'Installed']['TimeGenerated'].iloc[0]
                download_start_time = group[group['EventIdentifier'] == 'Download started']['TimeGenerated'].iloc[0]
                return install_time - download_start_time
            else:
                return pd.NaT

        durations = relevant_events.groupby('UpdateGUID').apply(calculate_duration)

        # Now that we have our time difference we need to merge left and bring the Software back into our dataframe so we know which updates took how long as the GUID is useless to humans
        durations_df = durations.reset_index()
        durations_df.columns = ['UpdateGUID', 'Duration']
        filtered_df_unique = filtered_df.drop_duplicates(subset='UpdateGUID', keep='first')
        merged_df = pd.merge(durations_df, filtered_df_unique[['UpdateGUID', 'Software']], on='UpdateGUID', how='left')
        merged_df = merged_df.drop(columns='UpdateGUID')

        # Now we need to sort the data based on the date in the Software column so we can see it in order
        merged_df['DurationHours'] = merged_df['Duration'].dt.total_seconds() / 3600
        merged_df['SoftwareDate'] = merged_df['Software'].str.extract(r'(\d{4}-\d{2})')
        merged_df['SoftwareDate'] = pd.to_datetime(merged_df['SoftwareDate'], format='%Y-%m')
        merged_df_sorted = merged_df.sort_values(by='SoftwareDate')

        fig = px.bar(merged_df_sorted, x='Software', y='DurationHours', 
                    labels={'DurationHours': 'Duration in Hours from Download to Install', 'Software': 'Windows Update'},
                    title='Duration of Software Updates in Hours from Download to Successful Install')

        fig.update_layout(xaxis_tickangle=-45)
        fig.update_layout(autosize=True)
        return fig, merged_df['Duration'].mean()
    except Exception as e:
        logger.error(f'The bar chart could not be rendered, sending back generic graph: {e}')
        return cgf.set_no_results_found_figure(), '0'


def generate_updates_graph(df):
    try:
        def _categorize_software(software):
            if 'Update for Windows 11' in software or 'Update for Windows 10' in software:
                return 'Windows System Update'
            elif 'Security Intelligence Update for Microsoft Defender Antivirus' in software:
                return 'Microsoft Defender Update'
            elif 'Update for Windows Security platform antimalware platform' in software:
                return 'Windows AntiMalware Update'
            elif 'Cumulative Update for .NET Framework' in software:
                return '.NET Framework Update'
            else:
                return 'Other'

        df['SoftwareType'] = df['Software'].apply(_categorize_software)

        installed_updates = df[
            ((df['Software'].str.contains('Update for Windows 11|Update for Windows 10', na=False)) & (df['EventIdentifier'] == 'Installed')) |
            ((df['Software'].str.contains('Security Intelligence Update for Microsoft Defender Antivirus', na=False)) & (df['EventIdentifier'] == 'Installed')) |
            ((df['Software'].str.contains('Update for Windows Security platform antimalware platform', na=False)) & (df['EventIdentifier'] == 'Installed')) |
            ((df['Software'].str.contains('Cumulative Update for .NET Framework', na=False)) & (df['EventIdentifier'] == 'Installed'))
        ][['TimeGenerated', 'SoftwareType']]

        installed_updates.loc[:, 'TimeGenerated'] = installed_updates['TimeGenerated'].str[:-4]
        installed_updates.loc[:, 'TimeGenerated'] = pd.to_datetime(installed_updates['TimeGenerated'], format='%Y%m%d%H%M%S.%f')
        warnings.filterwarnings("ignore", message="When grouping with a length-1 list-like")
        fig = px.scatter(installed_updates, x='TimeGenerated', y='SoftwareType', color='SoftwareType', title='System Updates Over Time')

        fig.update_layout(xaxis_title='Time Generated', yaxis_title='Software Type')
        return(fig)
    except Exception as e:
        logger.error(f'The scatter chart could not be rendered, sending back generic graph: {e}')
        cgf.set_no_results_found_figure()

    
model_id = 'em_11_vulnerability_patching'
patching_bar_chart, mean_time_to_patch = generate_patching_graphs(em_11_vulnerability_patching)
system_updates = generate_updates_graph(em_11_vulnerability_patching)


layout = html.Div([
    html.H2('Patch Management', style={'textAlign': 'center'}),
    html.A(
        dbc.Button("Patching Advice", id=f"{model_id}-help", color="danger", n_clicks=0, style={
            'width': '200px',
            'height': '56px',
            'position': 'absolute',
            'top': '10px',
            'right': '10px'
        }),
        href=f'https://www.ncsc.gov.uk/collection/top-tips-for-staying-secure-online/install-the-latest-software-and-app-updates',
        target="_blank"
    ),
    html.Div(id=f'{model_id}-dummy-div', style={'display': 'none'}),
    dbc.Button("Manage Patching", id=f"{model_id}-manage", color="success", n_clicks=0, style= {
        'width': '200px',
        'height': '56px',
        'position': 'absolute',
        'top': '10px',
        'right': '230px'
        }),
    html.Br(),
    html.P([
        'Patching is downloading and installing system updates to your system for security and new feature sets.',
        html.Br(),
        'For our purposes we are only going to look at the Microsoft windows KB (Knowledge Base) patches.',
        html.Br(),
        'These patches generally have security updates in them and are vital for keeping your system secure.',
        html.Br(),
        f'Your Mean time to patch, that is mean time from when you downloaded a patch until it was successfully installed was:',
        html.Br(),
        dcc.Markdown(f'**{mean_time_to_patch} hours**')
        ],
        style={'textAlign': 'center'}
    ),
    html.Br(),
    html.Div([dcc.Graph(figure=patching_bar_chart, style={'height': '800px', 'width': '100%'})]),
    html.Br(),
    html.P([
        'If you notice on the below graph that you have not been receiving updates recently (past month) this could be an indication there is an issue with your system patching.',
        html.Br(),
        'The Microsoft Defender Updates are very busy so you should see a lot of activity there, the Windows System update is your Monthly Patch Tuesday patches.',
        html.Br(),
        'The .NET Framework is less busy and the AntiMalware updates are only a few updates a year.',
        ],
        style={'textAlign': 'center'}
    ),
    html.Br(),
    html.Div([dcc.Graph(figure=system_updates, style={'height': '800px', 'width': '100%'})]),
    html.Div(id=f"{model_id}-hidden-output", style={"display": "none"}),
    html.H4("These are the system update events we have collected from your event logs", style={'textAlign': 'center'}),
    cgf.generate_dash_table(em_11_vulnerability_patching, 'em_11_vulnerability_patching'),
])


@callback(
    Output(f'{model_id}-dummy-div', 'children'),
    [Input(f"{model_id}-help", "n_clicks")]
)
def toggle_modal(n_clicks):
    if n_clicks > 0:
        logger.info(f'{model_id} Help button pressed')
        return ""
    return ""


@callback(
    Output(f"{model_id}-hidden-output", "children"),
    [Input(f"{model_id}-manage", "n_clicks")]
)
def launch_exe(n_clicks):
    if n_clicks > 0:
        logger.info(f'{model_id} Manage button pressed')
        try:
            cf.run_powershell_command('Start-Process "ms-settings:windowsupdate"')
            return "Launched successfully."
        except Exception as e:
            return f"Error: {e}"
    return ""